<!DOCTYPE html>
<html>
<head>
    <title>Penguin Fish Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #87CEEB; 
            touch-action: none; 
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas { 
            border: none; 
            background: #E0F6FF; 
            display: block;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
        }
        #score { 
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 6vw;
            color: #000;
            font-weight: bold;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
        }
        @media (min-width: 768px) {
            body { padding: 20px; overflow: visible; }
            canvas { 
                width: 800px; 
                height: 600px; 
                margin: 0 auto;
                border: 2px solid #000;
                object-fit: contain;
            }
            #score { 
                position: relative;
                font-size: 24px;
                margin: 10px 0;
                text-shadow: none;
            }
        }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <canvas id="game" width="800" height="600"></canvas>
    
    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        
        // Mobile responsive canvas setup
        function resizeCanvas() {
            if (window.innerWidth < 768) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            } else {
                canvas.width = 800;
                canvas.height = 600;
            }
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        const penguin = { x: canvas.width/2, y: canvas.height/2, size: 30 };
        const fish = [];
        const explosions = [];
        const polarBears = [];
        const waterHoles = [];
        let slowedUntil = 0;
        let gameStarted = false;
        let score = 0;
        let gameOver = false;
        let highScore = localStorage.getItem('penguinHighScore') || 0;
        
        // Audio setup
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Background music
        function playBackgroundMusic() {
            const melody = [261.63, 329.63, 392.00, 329.63, 261.63, 220.00, 261.63, 293.66, 329.63, 261.63, 220.00, 196.00];
            const bassLine = [130.81, 164.81, 196.00, 164.81, 130.81, 110.00, 130.81, 146.83, 164.81, 130.81, 110.00, 98.00];
            let noteIndex = 0;
            
            function playNote() {
                if (gameOver) return;
                
                const oscillator1 = audioContext.createOscillator();
                const gainNode1 = audioContext.createGain();
                oscillator1.connect(gainNode1);
                gainNode1.connect(audioContext.destination);
                oscillator1.frequency.setValueAtTime(melody[noteIndex], audioContext.currentTime);
                oscillator1.type = 'sawtooth';
                gainNode1.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode1.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
                oscillator1.start(audioContext.currentTime);
                oscillator1.stop(audioContext.currentTime + 0.2);
                
                const oscillator2 = audioContext.createOscillator();
                const gainNode2 = audioContext.createGain();
                oscillator2.connect(gainNode2);
                gainNode2.connect(audioContext.destination);
                oscillator2.frequency.setValueAtTime(bassLine[noteIndex], audioContext.currentTime);
                oscillator2.type = 'square';
                gainNode2.gain.setValueAtTime(0.08, audioContext.currentTime);
                gainNode2.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
                oscillator2.start(audioContext.currentTime);
                oscillator2.stop(audioContext.currentTime + 0.3);
                
                noteIndex = (noteIndex + 1) % melody.length;
                setTimeout(playNote, 250);
            }
            
            playNote();
        }
        
        // Eating sound effect
        function playEatingSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
            oscillator.type = 'square';
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        // Create game objects based on canvas size
        function createGameObjects() {
            fish.length = 0;
            polarBears.length = 0;
            waterHoles.length = 0;
            
            // Create random fish
            for (let i = 0; i < 20; i++) {
                const size = Math.random() < 0.3 ? 25 : Math.random() < 0.6 ? 20 : 15;
                fish.push({
                    x: Math.random() * (canvas.width - size),
                    y: Math.random() * (canvas.height - size),
                    size: size,
                    points: size === 25 ? 10 : size === 20 ? 5 : 1
                });
            }
            
            // Create polar bears
            for (let i = 0; i < 3; i++) {
                polarBears.push({
                    x: Math.random() * (canvas.width - 50),
                    y: Math.random() * (canvas.height - 50),
                    size: 50
                });
            }
            
            // Create water holes
            const holeCount = canvas.width < 768 ? 2 : 3;
            for (let i = 0; i < holeCount; i++) {
                waterHoles.push({
                    x: Math.random() * (canvas.width - 80) + 40,
                    y: Math.random() * (canvas.height - 80) + 40,
                    size: 40
                });
            }
        }
        
        createGameObjects();
        
        // Handle keyboard input
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key] = true);
        document.addEventListener('keyup', (e) => keys[e.key] = false);
        
        // Touch controls
        let isTouching = false;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            if (!gameStarted) {
                // Check play button tap
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const canvasX = x * scaleX;
                const canvasY = y * scaleY;
                
                if (canvasX >= canvas.width/2 - 100 && canvasX <= canvas.width/2 + 100 && 
                    canvasY >= canvas.height/2 + 50 && canvasY <= canvas.height/2 + 120) {
                    gameStarted = true;
                    audioContext.resume().then(() => {
                        playBackgroundMusic();
                    });
                }
            } else {
                isTouching = true;
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!gameStarted || !isTouching) return;
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const targetX = x * scaleX;
            const targetY = y * scaleY;
            
            const dx = targetX - penguin.x;
            const dy = targetY - penguin.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 5) {
                const speed = Date.now() < slowedUntil ? 2 : 4.5;
                penguin.x += (dx / distance) * speed;
                penguin.y += (dy / distance) * speed;
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isTouching = false;
        });
        
        // Handle mouse clicks for desktop
        canvas.addEventListener('click', function(e) {
            if (!gameStarted) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (x >= canvas.width/2 - 100 && x <= canvas.width/2 + 100 && 
                    y >= canvas.height/2 + 50 && y <= canvas.height/2 + 120) {
                    gameStarted = true;
                    audioContext.resume().then(() => {
                        playBackgroundMusic();
                    });
                }
            }
        });
        
        function update() {
            if (gameOver || !gameStarted) return;
            
            // Move penguin with keyboard
            if (!isTouching) {
                const speed = Date.now() < slowedUntil ? 2 : 4.5;
                if (keys['ArrowUp'] || keys['w']) penguin.y -= speed;
                if (keys['ArrowDown'] || keys['s']) penguin.y += speed;
                if (keys['ArrowLeft'] || keys['a']) penguin.x -= speed;
                if (keys['ArrowRight'] || keys['d']) penguin.x += speed;
            }
            
            // Keep penguin in bounds
            penguin.x = Math.max(penguin.size/2, Math.min(canvas.width - penguin.size/2, penguin.x));
            penguin.y = Math.max(penguin.size/2, Math.min(canvas.height - penguin.size/2, penguin.y));
            
            // Check fish collisions
            for (let i = fish.length - 1; i >= 0; i--) {
                const f = fish[i];
                const dist = Math.sqrt((penguin.x - f.x)**2 + (penguin.y - f.y)**2);
                if (dist < penguin.size/2 + f.size/2) {
                    explosions.push({
                        x: f.x, y: f.y, size: 0, maxSize: 40, life: 20
                    });
                    score += f.points;
                    penguin.size = 30 + Math.floor(score / 15) * 2;
                    fish.splice(i, 1);
                    document.getElementById('score').textContent = `Score: ${score}`;
                    playEatingSound();
                    
                    const size = Math.random() < 0.3 ? 25 : Math.random() < 0.6 ? 20 : 15;
                    fish.push({
                        x: Math.random() * (canvas.width - size),
                        y: Math.random() * (canvas.height - size),
                        size: size,
                        points: size === 25 ? 10 : size === 20 ? 5 : 1
                    });
                }
            }
            
            // Check polar bear collisions
            for (let i = 0; i < polarBears.length; i++) {
                const bear = polarBears[i];
                const dist = Math.sqrt((penguin.x - bear.x)**2 + (penguin.y - bear.y)**2);
                if (dist < penguin.size/2 + bear.size/2) {
                    gameOver = true;
                    if (score > highScore) {
                        highScore = score;
                        localStorage.setItem('penguinHighScore', highScore);
                    }
                    break;
                }
            }
            
            // Check water hole collisions
            for (let i = 0; i < waterHoles.length; i++) {
                const hole = waterHoles[i];
                const dist = Math.sqrt((penguin.x - hole.x)**2 + (penguin.y - hole.y)**2);
                if (dist < penguin.size/2 + hole.size/2) {
                    slowedUntil = Date.now() + 2000;
                    break;
                }
            }
            
            // Update explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                exp.size += 2;
                exp.life--;
                if (exp.life <= 0) explosions.splice(i, 1);
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!gameStarted) {
                // Draw start screen
                ctx.fillStyle = '#000';
                const titleSize = Math.min(canvas.width / 12, 64);
                ctx.font = `${titleSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('PENGUIN DASH', canvas.width/2, canvas.height/2 - 100);
                
                // Draw large penguin
                const displayPenguin = { x: canvas.width/2, y: canvas.height/2 - 20, size: Math.min(canvas.width / 8, 120) };
                
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.ellipse(displayPenguin.x, displayPenguin.y + displayPenguin.size/6, displayPenguin.size/2.5, displayPenguin.size/2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(displayPenguin.x, displayPenguin.y - displayPenguin.size/3.75, displayPenguin.size/3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.ellipse(displayPenguin.x, displayPenguin.y + displayPenguin.size/10, displayPenguin.size/4, displayPenguin.size/2.5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FFA500';
                ctx.beginPath();
                ctx.moveTo(displayPenguin.x - displayPenguin.size/6, displayPenguin.y - displayPenguin.size/3.75);
                ctx.lineTo(displayPenguin.x - displayPenguin.size/2.5, displayPenguin.y - displayPenguin.size/3.75);
                ctx.lineTo(displayPenguin.x - displayPenguin.size/3.75, displayPenguin.y - displayPenguin.size/6);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.ellipse(displayPenguin.x - displayPenguin.size/5, displayPenguin.y + displayPenguin.size*0.6, displayPenguin.size/7.5, displayPenguin.size/15, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(displayPenguin.x + displayPenguin.size/5, displayPenguin.y + displayPenguin.size*0.6, displayPenguin.size/7.5, displayPenguin.size/15, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(displayPenguin.x - displayPenguin.size/10, displayPenguin.y - displayPenguin.size/3, displayPenguin.size/15, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(displayPenguin.x + displayPenguin.size/10, displayPenguin.y - displayPenguin.size/3, displayPenguin.size/15, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(displayPenguin.x - displayPenguin.size/10, displayPenguin.y - displayPenguin.size/3, displayPenguin.size/30, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(displayPenguin.x + displayPenguin.size/10, displayPenguin.y - displayPenguin.size/3, displayPenguin.size/30, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw play button
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.roundRect(canvas.width/2 - 100, canvas.height/2 + 50, 200, 70, 20);
                ctx.fill();
                
                ctx.fillStyle = '#FFF';
                const buttonSize = Math.min(canvas.width / 25, 32);
                ctx.font = `${buttonSize}px Arial`;
                ctx.fillText('PLAY', canvas.width/2, canvas.height/2 + 90);
                
                ctx.textAlign = 'left';
                return;
            }
            
            // Draw penguin
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(penguin.x, penguin.y + penguin.size/6, penguin.size/2.5, penguin.size/2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(penguin.x, penguin.y - penguin.size/3.75, penguin.size/3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.ellipse(penguin.x, penguin.y + penguin.size/10, penguin.size/4, penguin.size/2.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.moveTo(penguin.x - penguin.size/6, penguin.y - penguin.size/3.75);
            ctx.lineTo(penguin.x - penguin.size/2.5, penguin.y - penguin.size/3.75);
            ctx.lineTo(penguin.x - penguin.size/3.75, penguin.y - penguin.size/6);
            ctx.closePath();
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(penguin.x - penguin.size/5, penguin.y + penguin.size*0.6, penguin.size/7.5, penguin.size/15, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(penguin.x + penguin.size/5, penguin.y + penguin.size*0.6, penguin.size/7.5, penguin.size/15, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(penguin.x - penguin.size/10, penguin.y - penguin.size/3, penguin.size/15, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(penguin.x + penguin.size/10, penguin.y - penguin.size/3, penguin.size/15, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(penguin.x - penguin.size/10, penguin.y - penguin.size/3, penguin.size/30, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(penguin.x + penguin.size/10, penguin.y - penguin.size/3, penguin.size/30, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw fish
            fish.forEach(f => {
                const color = f.size === 25 ? '#FFD700' : f.size === 20 ? '#FF8C00' : '#FF6B35';
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.ellipse(f.x, f.y, f.size/2, f.size/3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(f.x + f.size/2, f.y);
                ctx.lineTo(f.x + f.size/1.2, f.y - f.size/4);
                ctx.lineTo(f.x + f.size/1.2, f.y + f.size/4);
                ctx.closePath();
                ctx.fill();
                
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(f.x - f.size/6, f.y - f.size/8, f.size/8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(f.x - f.size/6, f.y - f.size/8, f.size/16, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw water holes
            waterHoles.forEach(hole => {
                ctx.fillStyle = '#4A90E2';
                ctx.beginPath();
                ctx.arc(hole.x, hole.y, hole.size/2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#2E5C8A';
                ctx.beginPath();
                ctx.arc(hole.x, hole.y, hole.size/3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw polar bears
            polarBears.forEach(bear => {
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.ellipse(bear.x, bear.y + 5, bear.size/2.5, bear.size/2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(bear.x, bear.y - 8, bear.size/3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(bear.x - 8, bear.y - 15, bear.size/8, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(bear.x + 8, bear.y - 15, bear.size/8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.moveTo(bear.x, bear.y - 8);
                ctx.lineTo(bear.x - 3, bear.y - 5);
                ctx.lineTo(bear.x + 3, bear.y - 5);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(bear.x - 5, bear.y - 12, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(bear.x + 5, bear.y - 12, 2, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw game over screen
            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#FFF';
                const gameOverSize = Math.min(canvas.width / 16, 48);
                ctx.font = `${gameOverSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2 - 60);
                
                const scoreSize = Math.min(canvas.width / 25, 32);
                ctx.font = `${scoreSize}px Arial`;
                ctx.fillText(`Your Score: ${score}`, canvas.width/2, canvas.height/2);
                ctx.fillText(`High Score: ${highScore}`, canvas.width/2, canvas.height/2 + 40);
                
                const refreshSize = Math.min(canvas.width / 33, 24);
                ctx.font = `${refreshSize}px Arial`;
                ctx.fillText('Refresh to play again', canvas.width/2, canvas.height/2 + 80);
                ctx.textAlign = 'left';
            }
            
            // Draw explosions
            explosions.forEach(exp => {
                const alpha = exp.life / 20;
                ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
                ctx.beginPath();
                ctx.arc(exp.x, exp.y, exp.size/2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = `rgba(255, 165, 0, ${alpha})`;
                ctx.beginPath();
                ctx.arc(exp.x, exp.y, exp.size/3, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        gameLoop();
    </script>
    
    <p style="display: none;">Use arrow keys or WASD to move the penguin and eat the fish!</p>
</body>
</html>
